<label for="cbHillshading"><input type="checkbox" id="cbHillshading">Relief hillshading (slow)</label>
<br>
<label for="cbRelief"><input type="checkbox" id="cbRelief" checked>Relief hypsometric tints</label>
<br>
<label for="cbCLC"><input type="checkbox" id="cbCLC" checked>Land cover waters</label>
<br>
<label for="cbPopulation"><input type="checkbox" id="cbPopulation" checked>Population dots</label>
<br>
<label for="cbLabels"><input type="checkbox" id="cbLabels" checked>City names</label>
<br>
<label for="cbBoundaries"><input type="checkbox" id="cbBoundaries" checked>Boundaries</label>
<br>
<label for="sSeaLavel"><input type="checkbox" id="cbSeaLevel" checked>Sea level: <span id="sliderValue"></span></label>
<input type="range" id="sSeaLavel" min="0" max="80" step="1" value="0" style="width:300px;">
<br>
<label for="cbHypssea"><input type="checkbox" id="cbHypssea">Adjust hypsometric colors to sea level</label>
<div id="map" style="height: 700px; width: 1000px"></div>

<script src="https://cdn.jsdelivr.net/npm/gridviz@3.0.27"></script>
<script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@2.2.2"></script>
<script src="https://cdn.jsdelivr.net/npm/gridviz-parquet@1.1.1"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-array@3.2.4"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
<script>



    //TODO
    //fix flooded areas in NL, etc. correct tiles - include <=0 cells. integrate with GEBCO ?
    //DEM 50m ?
    //improve menu
    //change hypsometric colors
    //improve hill shading
    //test/improve webgl
    //add some rivers ?


    const seaColor = "#a4c8e1"

    const map = new gridviz.Map(document.getElementById('map'), {
        x: 4200000, y: 2800000, z: 1000,
        backgroundColor: seaColor
    }).setZoomExtent([30, 4000])
        .addZoomButtons()

    const datasetRelief = new gridviz.MultiResolutionDataset(
        [100, 200, 500, 1000, 2000, 5000, 10000, 20000],
        resolution => new gviz_par.TiledParquetGrid(map,
            "https://raw.githubusercontent.com/jgaffuri/tiled-euroDEM/main/pub/v1/tiles_" + resolution + "/"),
        { preprocess: (c) => c.v != undefined && c.v > 0 }
    )

    const datasetPop = new gridviz.MultiResolutionDataset(
        [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000],
        resolution => new gviz_par.TiledParquetGrid(map,
            "https://raw.githubusercontent.com/jgaffuri/europop100m/main/pub/JRC_100m/" + resolution + "/"),
    )

    const datasetCLC = new gridviz.MultiResolutionDataset(
        [100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000],
        (resolution) => new gviz_par.TiledParquetGrid(map,
            'https://raw.githubusercontent.com/eurostat/LCMap/main/pub/clc/v1/2018/' + resolution + '/'),
        { preprocess: (c) => c.code == 40 || c.code == 41 || c.code == 42 || c.code == 43 || c.code == 44 }
    )


    //define style
    const colors = [
        //"#004529",
        "#006837",
        "#238443",
        "#41AB5D",
        "#78C679",
        "#ADDD8E",
        "#FEE08B",
        "#FDAE61",
        "#F46D43",
        "#D73027",
        "#A50026",
        //"#FFFFFF"
    ];
    const classNumber = colors.length


    const styleCLCWater = new gridviz.ShapeColorSizeStyle({ color: () => seaColor })
    /*const styleCLCWater = new gridviz.SquareColorCategoryWebGLStyle({
        code: (cell) => "a",
        color: { 'a': seaColor },
    })*/


    const scalePopulation = gridviz.logarithmicScale(-3)
    const stylePopulation = new gridviz.ShapeColorSizeStyle({
        viewScale: cells => d3.max(cells, c => +c.POP_2021),
        shape: () => "circle",
        size: (c, r, z, max) => {
            let t = +c.POP_2021 / max
            //t = Math.pow(t, 0.6)
            t = scalePopulation(t)
            t = r * t * 1.4
            if (t / z > 3) return t
        },
        color: () => "#444", //"#333",
    })

    shadingCoeff = 25
    reliefDirection = -1
    //TODO move to gridviz ?
    function getShadingStyle(field, shadingCoeff) {
        //define shading style
        const sideValue = (side) => {
            if (!side.c1) return 0
            if (!side.c2) return 0
            if (!side.c1[field]) return 0
            if (!side.c2[field]) return 0
            return +side.c2[field] - side.c1[field]
        }

        const scale = gridviz.exponentialScale(shadingCoeff)
        return new gridviz.SideStyle({
            color: (side, resolution) => {
                const dz = -sideValue(side) * reliefDirection
                if (dz == 0) return
                let coeff = resolution / dz * 0.01
                coeff = Math.abs(coeff)
                coeff = coeff > 1 ? 1 : coeff
                coeff = 1 - coeff
                coeff = scale(coeff)
                //coeff = Math.pow(coeff, 5)
                if ((dz < 0 && side.or === 'h') || (dz > 0 && side.or === 'v'))
                    return 'rgba(255,255,255,' + coeff + ')'
                return 'rgba(0,0,0,' + coeff + ')'
            },
            width: (side, r, z) => Math.min(2 * z, r / 3),
        })
    }
    const shadingStyle = getShadingStyle('v', shadingCoeff)


    const labelLayer = new gridviz.LabelLayer(gridviz_eurostat.getEuronymeLabelLayer('EUR', 20))
    const boundariesLayer = new gridviz.GeoJSONLayer(gridviz_eurostat.getEurostatBoundariesLayer({ col: "#444", scale: "03M" }))

    // tooltip content
    const cellInfoHTMLPop = (c) => `Population: ${c.POP_2021}`
    const cellInfoHTMLRelief = (c) => `Elevation: ${c.v}`

    const cbHillshading = document.getElementById("cbHillshading");
    const cbRelief = document.getElementById("cbRelief");
    const cbCLC = document.getElementById("cbCLC");
    const cbPopulation = document.getElementById("cbPopulation");
    const cbLabels = document.getElementById("cbLabels");
    const cbBoundaries = document.getElementById("cbBoundaries");
    const cbSeaLevel = document.getElementById("cbSeaLevel");

    const sSeaLavel = document.getElementById('sSeaLavel');
    const lbSeaLevel = document.getElementById('sliderValue');
    const cbHypssea = document.getElementById("cbHypssea");

    function update() {
        const seaLevel = +sSeaLavel.value;
        lbSeaLevel.textContent = sSeaLavel.value + ' m';

        const styleWater = new gridviz.ShapeColorSizeStyle({
            color: (c, r, z, vs) => {
                if (c.v > seaLevel) return
                return seaColor + "bb"
            }
        })

        const adj = cbHypssea.checked
        //const scaleRelief = gridviz.exponentialScale(-2)
        const scaleRelief = gridviz.logarithmicScale(-2)
        const styleRelief = new gridviz.ShapeColorSizeStyle({
            viewScale: cells => d3.extent(cells, c => +c.v),
            color: (c, r, z, vs) => {
                const min = adj ? Math.max(vs[0], seaLevel) : vs[0]
                let t = (c.v - min) / (vs[1] - min)
                //t = Math.pow(t, 0.6)
                t = scaleRelief(t)
                t = Math.floor(t * classNumber)
                if (t > 11) t = 11
                return colors[t]
            },
            size: (c, r) => r * 1.1
        })


        const layers = []
        // relief
        if (cbRelief.checked) layers.push(new gridviz.GridLayer(datasetRelief, [styleRelief], { minPixelsPerCell: 1.6, cellInfoHTML: cellInfoHTMLRelief }))
        //relief shading
        if (cbHillshading.checked) layers.push(new gridviz.GridLayer(datasetRelief, [shadingStyle], { minPixelsPerCell: 1.6, cellInfoHTML: 'none' }))
        // CLC waters
        if (cbCLC.checked) layers.push(new gridviz.GridLayer(datasetCLC, [styleCLCWater], { minPixelsPerCell: 1.6, cellInfoHTML: 'none' }))
        // population
        if (cbPopulation.checked) layers.push(new gridviz.GridLayer(datasetPop, [stylePopulation], { minPixelsPerCell: 4, cellInfoHTML: cellInfoHTMLPop }))
        //boundaries
        if (cbBoundaries.checked) layers.push(boundariesLayer);
        // sea level
        if (cbSeaLevel.checked) layers.push(new gridviz.GridLayer(datasetRelief, [styleWater], { minPixelsPerCell: 1.6, cellInfoHTML: 'none' }))
        // labels
        if (cbLabels.checked) layers.push(labelLayer)
        map.layers = layers

        map.redraw()
    }

    // sea level GUI
    sSeaLavel.addEventListener('input', update);
    // hill shading GUI
    cbHillshading.addEventListener("change", update);
    cbRelief.addEventListener("change", update);
    cbCLC.addEventListener("change", update);
    cbPopulation.addEventListener("change", update);
    cbLabels.addEventListener("change", update);
    cbBoundaries.addEventListener("change", update);
    cbSeaLevel.addEventListener("change", update);
    cbHypssea.addEventListener("change", update);

    update()
</script>